# BCZY3
第三次编程作业
1.找连通网的最小生成树，经典的有两种算法，普里姆算法和克鲁斯卡尔算法。
2.普利姆算法：从任意顶点开始构建生成树，然后依次将代价最小的其他顶点纳入生成树，直到所有顶点都被纳入为止。（适用于边比较多的图）
3.克鲁斯卡尔算法：每次选择一条权值最小的边，让这条边两端的顶点连通，如果这条边两端的顶点已连通，则不选。（适用于边比较少的图）
4.解决最短路径问题的方法：迪杰斯特拉算法，弗洛伊德算法
5.迪杰斯特拉（Dijkstra）算法：按路径长度递增的次序产生最短路径的算法
1）把起点S加入网络  2）更新刚入网的节点的直连节点的working value(从起点到该点，某条路径的路程）  3）把全局中，working value最小的节点加入网络，并将其working value记为final value  4)重复2，3，直至所有点进入
6.弗洛伊德（Floyd）算法：通过三重循环，k为中转点，v为起点，w为终点，若D[v][k]+D[k][w]为更小值，则把D[v][k]+D[k][w]覆盖保存在D[v][w]中
<img width="326" alt="image" src="https://user-images.githubusercontent.com/111118849/186650736-c4bf1261-7497-4458-9176-4677a307cae8.png">
注：十字加法，若所得数小于十字中心数则更新，若不小于则不更新，∞那一行列忽略
       加黑字体为更新数据，最后得到的矩阵中每个元素都是两点间最短距离
7.AOV-网：用顶点表示活动，用弧表示活动间的优先关系的有向无环图。
8.AOV-网的特性：1）可传递性 2）不唯一
9.拓扑序列：设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v1 ，v2，……，vn，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。则我们称这样的顶点序列为一个拓扑序列。
10.拓扑排序：在一个有向图中找一个拓扑序列的过程
11.求拓扑排序的基本思想：1）从有向图中选一个无前驱（入度为0）的顶点输出  2）将此顶点和以它为起点的弧删除  3）重复12，直到不存在无前驱的顶点  4）若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在回路，否则输出的顶点的顺序即为一个拓扑序列。
12.关键路径：
<img width="307" alt="image" src="https://user-images.githubusercontent.com/111118849/186650679-937b2f57-9275-4f9f-ae1b-6e29ab4fc053.png">
ve:从起点到该点最长的路程  vl:后一个节点的ve减去该节点的权重
e:例，a4连接的前一个节点是v2,所以a4的e是ve(2)=6
I:例，a2连接的后一个节点是v3,所以a2的I是vl(3)-a2=2
13.顺序表查找：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。
14.有序表查找：1）折半查找：它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。 2）插值查找：插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式(key-a[low])/(a[high]-a[low])。 3）斐波那契查找算法的核心在于：（1）当key=a[mid]时，查找就成功；（2）当key<a[mid]时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个；（3）当key>a[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个。（4）还有比较关键的一点，折半查找是进行加法与除法运算（mid=(low＋high)/2），插值查找进行复杂的四则运算（mid=low＋(high-low)*(key-a[low])/(a[high]-a[low])），而斐波那契查找只是最简单加减法运算（mid=low＋F[k-1]-1）
15.线性索引查找：1）稠密索引：在线性索引中，将数据集中的每个记录对应一个索引项  2）分块索引：（1）分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：块内无序，即每一块内的记录不要求有序。块间有序（要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字）。（2）对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。我们定义的分块索引的索引项结构分三个数据项：最大关键码，它存储每一块中的最大关键字；存储了块中的记录个数，以便于循环时使用；用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。（3）在分块索引表中查找，就是分两步进行：在分块索引表中查找要查关键字所在的块。然后根据块首指针找到相应的块，并在块中顺序查找关键码。  3）倒排索引：索引项的通用结构是：次关键码，记录号表，其中记录号表存储具有相同次关键字的所有记录的记录号。
16.二叉排序树：它或者是一棵空树，或者是具有下列性质的二叉树。若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。
<img width="190" alt="image" src="https://user-images.githubusercontent.com/111118849/186650641-e8a448b9-e990-4e44-bb26-ec12c7aeb9a4.png">
<img width="183" alt="image" src="https://user-images.githubusercontent.com/111118849/186650616-bf9fa648-2d1e-498e-aac5-d9c880e7ee62.png">
中序遍历：8，11，23，34，39，46，68，71，75，86
插入23，52：1）查看是否存在要插入元素 2）根据二叉树性质插入
<img width="197" alt="image" src="https://user-images.githubusercontent.com/111118849/186650571-0918f5a2-903c-489b-8801-7395b98a2a2a.png">
删除元素：（要保证二叉排序树的性质不丢失，高度不增加）1）删除叶子结点（直接删除）  2）被删除节点无左子树或无右子树：用其子树代替  3）左右都有孩子：用左子树中最大的或右子树中最小的元素来代替
17.平衡二叉树：要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子BF）不超过1。
18.平衡二叉树的调整：
<img width="174" alt="image" src="https://user-images.githubusercontent.com/111118849/186650502-933a0bbc-46dc-4108-9ca0-35619225bec3.png">
<img width="214" alt="image" src="https://user-images.githubusercontent.com/111118849/186650529-ef89052e-26b1-40be-b383-ab2313c6826b.png">
<img width="309" alt="image" src="https://user-images.githubusercontent.com/111118849/186650448-f52237fd-307d-4a37-9a31-cf9b390e9624.png">
19.多路查找树，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。我们讲解它的4种特殊形式：2-3树、2-3-4树、B树和B+树。
20.2-3树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。1）一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。2）一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。
<img width="275" alt="image" src="https://user-images.githubusercontent.com/111118849/186650357-068258ce-0d08-494d-9e37-979ebd093429.png">
21.2-3树的插入：1）对于空树，插入一个2结点即可 2）插入结点到一个2结点的叶子上。应该说，由于其本身就只有一个元素，所以只需要将其升级为3结点即可。
<img width="416" alt="image" src="https://user-images.githubusercontent.com/111118849/186650323-09116d3e-b94a-4223-aead-f55c34d579a3.png">
3）要往3结点中插入一个新元素。
（1）<img width="376" alt="image" src="https://user-images.githubusercontent.com/111118849/186650311-3e6bfd97-02de-4b83-81b3-782cd20970a6.png">
（2）<img width="384" alt="image" src="https://user-images.githubusercontent.com/111118849/186650283-5bebcaea-9f83-412d-8e09-0c1fb826039d.png">
（3）<img width="387" alt="image" src="https://user-images.githubusercontent.com/111118849/186650249-1fe32d36-c07b-47da-a2b0-266a40575647.png">
22.2-3树的删除：1）所删除元素位于一个3结点的叶子结点上， 只需要在该结点处删除该元素即可。2）所删除的元素位于一个2结点上，即要删除一个只有一个元素的结点。（不可直接删除，删除后此结点不满足有两个孩子的2结点定义）分为四种情况
（1）<img width="376" alt="image" src="https://user-images.githubusercontent.com/111118849/186650212-e8de7dd0-fc89-4a68-aa73-c45843e28638.png">
（2）<img width="384" alt="image" src="https://user-images.githubusercontent.com/111118849/186650177-348cc3a0-f1d1-4b78-b969-9e23207cd12b.png">
（3）<img width="292" alt="image" src="https://user-images.githubusercontent.com/111118849/186650136-e27ad686-a247-4afa-9f24-89e4ece01c00.png">
（4）<img width="268" alt="image" src="https://user-images.githubusercontent.com/111118849/186650111-002854e2-31d5-4a8e-92e9-f9e91adcfbd6.png">
3）所删除的元素位于非叶子的分支结点。此时我们通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让它们来补位即可。
<img width="415" alt="image" src="https://user-images.githubusercontent.com/111118849/186649934-21222826-a405-4aa5-993b-6b0a168a0e15.png">
<img width="416" alt="image" src="https://user-images.githubusercontent.com/111118849/186649910-441ca079-ce18-4d28-9e2f-19c583f9f1d3.png">
23.2-3-4树：是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。
例题：构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树
<img width="415" alt="image" src="https://user-images.githubusercontent.com/111118849/186649876-5e439980-373e-4c35-8709-e9308ebc6bd4.png">
依次删除1、6、3、4、5、2、9
<img width="415" alt="image" src="https://user-images.githubusercontent.com/111118849/186649835-ac547cc9-325a-49d9-a872-cd54c91f9791.png">
24.B树：满足平衡二叉树的多路平衡查找树。结点最大的孩子数目称为B树的阶，因此，2-3树是3阶B树，2-3-4树是4阶B树。
25.一个m阶的B树具有如下属性：1）树中每个结点至多有m个孩子结点  2）如果根结点不是叶结点，则其至少有两棵子树。3）除根结点外，其他结点至少有m/2个孩子结点4）每一个非根的分支结点都有k-1个元素和k个孩子。5）所有叶子结点都位于同一层次。
<img width="364" alt="image" src="https://user-images.githubusercontent.com/111118849/186649791-2243a010-10ad-443c-8b1c-0293ccfe1c8e.png">
26.一颗4阶的B+树
<img width="335" alt="image" src="https://user-images.githubusercontent.com/111118849/186649765-eb32a945-372a-4585-bfe1-e4caf5f2f182.png">
27.一棵m阶的B+树和m阶的B树的差异在于：1）有n棵子树的结点中包含有n个关键字；2）所有的叶子结点链接成一个线性链表且包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本依关键字的大小自小而大顺序链接（可用于顺序查找）3）非叶子结点只起索引作用，结点中仅含有其子树中的最大（或最小）关键字。
28.B+树的优点：随机查找时，从根结点出发，与B树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，它只是用来索引的，不提供实际记录的访问，还是需要到达包含此关键字的终端结点。需要进行从小到大的顺序查找时，可以从最左侧的叶子结点出发，不经过分支结点，延着指向下一叶子的指针就可遍历所有的关键字。
29.散列技术：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）。查找时，根据这个确定的对应关系找到给定值key的映射f（key），若查找集合中存在这个记录，则必定在f（key）的位置上。这里把这种对应关系f称为散列函数或哈希函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。关键字对应的记录存储位置称为散列地址。
30.散列过程有两步：（1）在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。（2）当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。
31.散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构。
32.散列技术中最关键的问题：设计简单、均匀、存储利用率高的散列函数和如何处理冲突
33.常用的散列函数构建方法：1）直接定址法：需要事先知道关键字的分布情况，适合查找表较小且连续的情况  2）数字分析法：使用关键字的一部分来计算散列存储位置的方法，适合处理关键字位数比较大的情况，需要事先知道关键字的分布且关键字的若干位分布较均匀  3）平方取中法：适合于不知道关键字的分布，而位数又不是很大的情况  4）折叠法：将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址，适合事先不需要知道关键字的分布，关键字位数较多的情况。  5）除留余数法：对于散列表长为m的散列函数公式为：f(key)=key mod p(p≤m)（最常用，p的选取很关键）  6）随机数法：选择一个随机数，取关键字的随机函数值为它的散列地址。也就是f(key)=random(key)。适用于关键字的长度不等时。
34.处理冲突的方法：1）开放定址法：fi(key)=(f(key)+di)MOD  m(di=1,2,3,......,m-1)，例：
{12,67,56,16,25,37,22,29,15,47,48,34}  用散列函数f(key)=key mod 12
<img width="416" alt="image" src="https://user-images.githubusercontent.com/111118849/186649710-014150e1-924f-4a2f-b181-45a1bfe7d2c0.png">
37与25冲突，所以f(37)=(f(37)+1)mod 12=2
<img width="415" alt="image" src="https://user-images.githubusercontent.com/111118849/186649652-ae13a552-846e-4382-81e9-fa4409ac5179.png">
<img width="415" alt="image" src="https://user-images.githubusercontent.com/111118849/186649516-ea64ba1c-0df6-4b64-8836-2d13697953d0.png">
48与12冲突，f(48)=(f(48)+1)mod 12=1，与25冲突，f(48)=(f(48)+2)mod 12=2，与37冲突，f(48)=(f(48)+6)mod 12=6
<img width="416" alt="image" src="https://user-images.githubusercontent.com/111118849/186649485-63d4c0c3-f258-4fe9-98e6-b36c1a465b09.png">
注：我们把这种解决冲突的开放定址法称为线性探测法。不是同义词却需要争夺一个地址的情况，我们称这种现象为堆积。改进1^2,-1^2,2^2,-2^2,......,q^2,-q^2,(q≤m/2)，这样就等于是可以双向寻找到可能的空位置,增加平方运算的目的是为了不让关键字都聚集在某一块区域。我们称这种方法为二次探测法。还有一种方法是，在冲突时，对于位移量di采用随机函数计算得到，我们称之为随机探测法。
2）再散列函数法：事先准备多个散列函数，每当发生散列地址冲突时，就换一个散列函数计算。  3）链地址法：将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。<img width="67" alt="image" src="https://user-images.githubusercontent.com/111118849/186649413-099e77b2-eab5-460c-a12e-4fce8b331953.png">
4）公共溢出区法：为所有冲突的关键字建立了一个公共的溢出区来存放，在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。
35.散列表查找性能分析：如果没有冲突，散列查找是我们本章介绍的所有查找中效率最高的，因为它的时间复杂度为O(1)
36.散列查找的平均查找长度取决于1．散列函数是否均匀2．处理冲突的方法3．散列表的装填因子（装填因子α=填入表中的记录个数/散列表长度）
37.排序：使序列成为一个按关键字有序的序列{rp1,rp2,......,rpn}，依据是关键字之间的大小关系
38.排序的稳定性判断：假设ki=kj(1≤i≤n,1≤j≤n,i≠j），且在排序前的序列中ri领先于rj（即i<j）。如果排序后ri仍领先于rj，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中rj领先ri，则称所用的排序方法是不稳定的。
39.内排序与外排序：内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。我们这里主要就介绍内排序的多种方法。
40.对于内排序来说，排序算法的性能主要是受3个方面影响：1）时间性能：在内排序中，主要进行两种操作：比较和移动。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。2）辅助空间：辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。3）算法本身的复杂性：内排序分为：插入排序、交换排序、选择排序和归并排序。
41.冒泡排序：交换排序，它的基本思想是两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。
42.冒泡排序的复杂度分析：当最好的情况，排序表本身有序，根据改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表逆序，此时需要比较n(n-1)/2次，并作等数量级的记录移动。总的时间复杂度为O(n2)。
43.简单选择排序：通过n-i次关键字间的比较，从n-i＋1个记录中选出关键字最小的记录，并和第i（1≤i≤n）个记录交换之。
44.简单排序的时间复杂度：无论最好最差的情况，都需要比较n(n-1)/2次。而对于交换次数，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n2)。
45.直接插入排序：将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。
46.直接插入排序复杂度分析：从空间上来看，它只需要一个记录的辅助空间，因此关键是看它的时间复杂度。最好的情况，排序表本身有序，只需比较(n-1)次，没有移动的记录，时间复杂度为O(n)。当最坏的情况，即待排序表逆序，需要比较(n+2)(n-1)/2次，而记录的移动次数要(n+4)(n-1)/2次。因此，我们得出直接插入排序法的时间复杂度为O(n2)。
47.希尔排序：分组+插入排序，第一次分组间隔一般为队列一半，之后每次减半直到为1。
48.希尔排序时间复杂度：当增量序列为dlta[k]=2t-k+1-1（0≤k≤t≤）时，可以获得不错的效率，其时间复杂度为O(n3/2)，要好于直接排序的O(n2)。
49.由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。
50.堆排序：对简单选择排序进行的一种改进，它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列了。
<img width="152" alt="image" src="https://user-images.githubusercontent.com/111118849/186649306-f2d9eee6-a71f-4304-8626-fc9a65648937.png">
51.堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。
52.堆排序复杂度分析：在构建堆的过程中，对于每个非终端结点来说，最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为O(n)。在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间，并且需要取n-1次堆顶记录，因此重建堆的时间复杂度为O(nlogn)。由于堆排序对原始记录的排序状态并不敏感，因此无论是最好、最坏和平均时间复杂度均为O(nlogn)。不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。
53.归并排序：<img width="349" alt="image" src="https://user-images.githubusercontent.com/111118849/186649174-fa094ae6-8dd5-484e-87ff-5e6a8777f08b.png">
54.快速排序：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。
55.快速排序复杂度分析：在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。此时需要执行n-1次递归调用，因此比较次数为n(n-1)/2，最终其时间复杂度为O(n2)。由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。
56.排序总结：<img width="415" alt="image" src="https://user-images.githubusercontent.com/111118849/186649100-c34a8fc4-0485-41c3-8aa1-35753a730ff1.png">
<img width="415" alt="image" src="https://user-images.githubusercontent.com/111118849/186649140-d4dcd55c-ffc9-490b-b79e-57697f819c22.png">


